<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>OpenDraw WebUI v.2.27 -farukguler.com</title>
    <script src="jspdf.umd.min.js"></script>
    <script src="rough.min.js"></script>
    <style>
        :root {
            --bg-color: #f8f9fa;
            --toolbar-bg: white;
            --toolbar-border: #e1e5e9;
            --toolbar-shadow: rgba(0, 0, 0, 0.1);
            --text-color: #374151;
            --btn-bg: transparent;
            --btn-border: #e1e5e9;
            --btn-hover-bg: #f3f4f6;
            --btn-hover-border: #d1d5db;
            --btn-active-bg: #3b82f6;
            --btn-active-border: #3b82f6;
            --btn-active-color: white;
            --canvas-bg: white;
            --properties-panel-bg: white;
            --properties-panel-border: #e1e5e9;
            --properties-panel-shadow: rgba(0, 0, 0, 0.1);
            --label-color: #6b7280;
            --modal-bg: #fefefe;
            --modal-border: #888;
            --modal-close-color: #aaa;
            --export-btn-bg: #f0f0f0;
            --export-btn-border: #ccc;
            --export-btn-hover-bg: #e0e0e0;
        }

        body.dark-mode {
            --bg-color: #1a1a1a;
            --toolbar-bg: #2c2c2c;
            --toolbar-border: #3a3a3a;
            --toolbar-shadow: rgba(0, 0, 0, 0.3);
            --text-color: #e0e0e0;
            --btn-bg: #3a3a3a;
            --btn-border: #4a4a4a;
            --btn-hover-bg: #4a4a4a;
            --btn-hover-border: #5a5a5a;
            --btn-active-bg: #3b82f6;
            --btn-active-border: #3b82f6;
            --btn-active-color: white;
            --canvas-bg: #2c2c2c;
            --properties-panel-bg: #2c2c2c;
            --properties-panel-border: #3a3a3a;
            --properties-panel-shadow: rgba(0, 0, 0, 0.3);
            --label-color: #b0b0b0;
            --modal-bg: #2c2c2c;
            --modal-border: #4a4a4a;
            --modal-close-color: #b0b0b0;
            --export-btn-bg: #3a3a3a;
            --export-btn-border: #4a4a4a;
            --export-btn-hover-bg: #4a4a4a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-color);
            overflow: hidden;
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* Toolbar Styles */
        .toolbar {
            background: var(--toolbar-bg);
            border-bottom: 1px solid var(--toolbar-border);
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 20px;
            box-shadow: 0 1px 3px var(--toolbar-shadow);
            z-index: 1000;
            flex-wrap: wrap;
            justify-content: space-between;
        }

        .app-title {
            margin-left: auto;
            font-weight: bold;
            font-size: 1.2em;
            color: var(--text-color);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tool-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 12px;
            border-right: 1px solid var(--toolbar-border);
        }

        .tool-group:last-child {
            border-right: none;
        }

        .tool-btn, .action-btn {
            background: var(--btn-bg);
            border: 1px solid var(--btn-border);
            border-radius: 6px;
            padding: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            color: var(--text-color);
        }

        .tool-btn:hover, .action-btn:hover {
            background: var(--btn-hover-bg);
            border-color: var(--btn-hover-border);
        }

        .tool-btn.active {
            background: var(--btn-active-bg);
            border-color: var(--btn-active-border);
            color: var(--btn-active-color);
        }

        input[type="color"] {
            width: 40px;
            height: 32px;
            border: 1px solid var(--btn-border);
            border-radius: 6px;
            cursor: pointer;
            background: var(--btn-bg);
        }

        input[type="range"] {
            width: 80px;
        }

        /* Canvas Container */
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: var(--canvas-bg);
        }

        #canvas {
            display: block;
            cursor: crosshair;
            background: var(--canvas-bg);
        }

        .text-input {
            position: absolute;
            border: 2px dashed var(--btn-active-bg);
            background: transparent;
            font-size: 16px; /* Default font size */
            font-family: inherit;
            outline: none;
            padding: 4px;
            min-width: 100px;
            resize: none;
            color: var(--text-color);
            text-align: left; /* Default text align */
            font-weight: normal;
            font-style: normal;
            text-decoration: none;
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: var(--modal-bg);
            padding: 20px;
            border: 1px solid var(--modal-border);
            width: 80%;
            max-width: 400px;
            border-radius: 8px;
            text-align: center;
            position: relative;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            color: var(--modal-close-color);
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-btn:hover,
        .close-btn:focus {
            color: var(--text-color);
            text-decoration: none;
        }

        .export-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .export-btn {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: 1px solid var(--export-btn-border);
            border-radius: 5px;
            background-color: var(--export-btn-bg);
            color: var(--text-color);
            transition: background-color 0.2s ease;
        }

        .export-btn:hover {
            background-color: var(--export-btn-hover-bg);
        }

        #clearBtn {
            background-color: #ef4444;
            color: white;
            border-color: #ef4444;
        }

        #clearBtn:hover {
            background-color: #dc2626;
            border-color: #dc2626;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .toolbar {
                padding: 8px 12px;
                gap: 8px;
            }
            
            .tool-group {
                gap: 4px;
                padding: 0 8px;
                margin: 2px 0;
            }
            
            .tool-btn, .action-btn {
                padding: 6px;
            }
            
            .properties-panel {
                top: 60px;
                right: 10px;
                left: 10px;
                min-width: unset;
            }

            input[type="range"] {
                width: 60px;
            }
        }

        @media (max-width: 480px) {
            .toolbar {
                padding: 6px 8px;
                gap: 4px;
            }

            .tool-group {
                padding: 0 4px;
                border-right: none;
                margin: 2px 0;
            }

            .tool-btn, .action-btn {
                padding: 4px;
            }

            input[type="color"] {
                width: 32px;
                height: 28px;
            }

            input[type="range"] {
                width: 50px;
            }
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .properties-panel {
            animation: fadeIn 0.2s ease;
        }

        /* Loading state */
        .loading {
            opacity: 0.7;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="toolbar">
            <div class="tool-group">
                <button class="tool-btn active" data-tool="select" title="Select">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
                    </svg>
                </button>
                <button class="tool-btn" data-tool="rectangle" title="Rectangle">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                    </svg>
                </button>
                <button class="tool-btn" data-tool="circle" title="Circle">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                    </svg>
                </button>
                <button class="tool-btn" data-tool="line" title="Line">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M5 12h14"/>
                    </svg>
                </button>
                <button class="tool-btn" data-tool="triangle" title="Triangle">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>
                    </svg>
                </button>
                <button class="tool-btn" data-tool="cylinder" title="Database">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <ellipse cx="12" cy="5" rx="9" ry="3"/>
                        <path d="M3 5v14a9 3 0 0 0 18 0V5"/>
                    </svg>
                </button>
                <button class="tool-btn" data-tool="cloud" title="Cloud">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"/>
                    </svg>
                </button>
                
                <button class="tool-btn" data-tool="arrow" title="Arrow">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M5 12h14"/>
                        <path d="M12 5l7 7-7 7"/>
                    </svg>
                </button>
                <button class="tool-btn" data-tool="pen" title="Pen">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/>
                    </svg>
                </button>
                
                
                <button class="tool-btn" data-tool="eraser" title="Eraser">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M16 2L21 7L11 17L6 12L16 2Z" />
                        <path d="M21 7L16 12" />
                        <path d="M11 17L6 12" />
                    </svg>
                </button>
            </div>

            <div class="tool-group">
                <input type="color" id="strokeColor" value="#000000" title="Stroke Color">
                <input type="color" id="fillColor" value="#ffffff" title="Fill Color">
                <input type="range" id="strokeWidth" min="1" max="10" value="2" title="Stroke Width">
            </div>

            <div class="tool-group">
                <button class="action-btn" id="undoBtn" title="Undo">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 7v6h6"/>
                        <path d="M21 17a9 9 0 00-9-9 9 9 0 00-6 2.3L3 13"/>
                    </svg>
                </button>
                <button class="action-btn" id="redoBtn" title="Redo">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 7v6h-6"/>
                        <path d="M3 17a9 9 0 019-9 9 9 0 016 2.3l3 2.7"/>
                    </svg>
                </button>
                <button class="action-btn" id="clearBtn" title="Clear">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="3,6 5,6 21,6"/>
                        <path d="M19,6V20a2,2,0,0,1-2,2H7a2,2,0,0,1-2-2V6m3,0V4a2,2,0,0,1,2-2h4a2,2,0,0,1,2,2V6"/>
                    </svg>
                </button>
            </div>

            <div class="tool-group">
                <button class="action-btn" id="exportBtn" title="Export">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7,10 12,15 17,10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                </button>
                <input type="file" id="importBtn" accept=".json" style="display: none;">
                <button class="action-btn" onclick="document.getElementById('importBtn').click()" title="Import (JSON)">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="17,8 12,3 7,8"/>
                        <line x1="12" y1="3" x2="12" y2="15"/>
                    </svg>
                </button>
                <input type="file" id="imageInput" accept="image/*" style="display: none;">
                <button class="action-btn" onclick="document.getElementById('imageInput').click()" title="Add Image">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                        <circle cx="8.5" cy="8.5" r="1.5"/>
                        <polyline points="21 15 16 10 5 21"/>
                    </svg>
                </button>
            </div>

            <div class="tool-group">
                <button class="action-btn" id="themeToggleBtn" title="Toggle Theme">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="5"/>
                        <line x1="12" y1="1" x2="12" y2="3"/>
                        <line x1="12" y1="21" x2="12" y2="23"/>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                        <line x1="1" y1="12" x2="3" y2="12"/>
                        <line x1="21" y1="12" x2="23" y2="12"/>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                    </svg>
                </button>
            </div>
            <div class="tool-group app-title">
                OpenDraw WebUI v.2.27
                <button class="action-btn" id="infoBtn" title="About">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="16" x2="12" y2="12"></line>
                        <line x1="12" y1="8" x2="12.01" y2="8"></line>
                    </svg>
                </button>
            </div>
        </div>

        

        <div class="canvas-container">
            <canvas id="canvas"></canvas>
            
        </div>

        <div id="exportModal" class="modal" style="display: none;">
            <div class="modal-content">
                <span class="close-btn" id="closeExportModal">&times;</span>
                <h3>Export Options</h3>
                <div class="export-options">
                    <button class="export-btn" data-format="png">PNG</button>
                    <button class="export-btn" data-format="jpg">JPG</button>
                    <button class="export-btn" data-format="pdf">PDF</button>
                    <button class="export-btn" data-format="json">JSON Project</button>
                </div>
            </div>
        </div>

        <div id="infoModal" class="modal" style="display: none;">
            <div class="modal-content">
                <span class="close-btn" id="closeInfoModal">&times;</span>
                <h3>About</h3>
                <div style="text-align: left; margin-top: 20px; line-height: 1.6;">
                    <p><strong>Name:</strong> OpenDraw WebUI</p>
                    <p><strong>Version:</strong> v.2.27</p>
                    <p><strong>Author:</strong> faruk-guler</p>
                    <p><strong>License:</strong> GPLv3</p>
                    <p style="margin-top: 15px;">This is an open-source, web-based drawing application created using the <strong>rough.js</strong> library. It allows you to create diagrams and drawings with a sketchy, hand-drawn look.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        class DrawingApp {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.rc = rough.canvas(this.canvas); // Initialize Rough.js
                this.elements = [];
                this.history = [];
                this.historyIndex = -1;
                this.currentTool = 'select';
                this.isDrawing = false;
                this.startX = 0;
                this.startY = 0;
                this.currentElement = null;
                this.selectedElement = null; // Only single selection now
                this.clipboard = null; // Only single element clipboard
                this.penPath = [];
                this.eraserRadius = 10;
                this.selectionTolerance = 5;
                this.roughness = 1; // Controls the "sketchiness" of Rough.js drawings, slightly increased from 1.5

                // Canvas pan and zoom
                this.offsetX = 0;
                this.offsetY = 0;
                this.zoomLevel = 1;
                this.isPanning = false;
                this.lastPanX = 0;
                this.lastPanY = 0;
                this.keys = {};
                this.dragOffset = { x: 0, y: 0 }; // Added for dragging selected elements

                // Theme state
                this.isDarkMode = false;
                this.themeToggleBtn = document.getElementById('themeToggleBtn');
                this.sunIconSVG = `
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="5"/>
                        <line x1="12" y1="1" x2="12" y2="3"/>
                        <line x1="12" y1="21" x2="12" y2="23"/>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                        <line x1="1" y1="12" x2="3" y2="12"/>
                        <line x1="21" y1="12" x2="23" y2="12"/>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                    </svg>
                `;
                                this.moonIconSVG = `
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                    </svg>
                `;

                this.init();
            }

            init() {
                this.setupCanvas();
                this.setupEventListeners();
                this.loadTheme();
                this.saveState();
            }

            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                this.redraw();
            }

            setupEventListeners() {
                // Tool buttons
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentTool = btn.dataset.tool;
                        this.selectedElement = null; // Deselect on tool change
                        this.updateToolbarsOnSelection();
                        this.redraw();
                    });
                });

                // Canvas events
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('dblclick', (e) => this.handleDoubleClick(e));
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));

                // Keyboard events for panning and shortcuts
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    // Prevent spacebar from panning when a text input is focused
                    if (e.code === 'Space' && document.activeElement !== this.textInput) {
                        e.preventDefault();
                        this.canvas.style.cursor = 'grab';
                    }
                    if (e.ctrlKey || e.metaKey) {
                        switch (e.key) {
                            case 'z':
                                e.preventDefault();
                                this.undo();
                                break;
                            case 'y':
                                e.preventDefault();
                                this.redo();
                                break;
                            case 'c':
                                e.preventDefault();
                                this.copySelectedElement(); // Simplified for single element
                                break;
                            case 'v':
                                e.preventDefault();
                                this.pasteElement(); // Simplified for single element
                                break;
                        }
                    }
                    if (e.key === 'Delete' && this.selectedElement) {
                        this.deleteSelectedElement();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                    if (e.code === 'Space') {
                        this.canvas.style.cursor = 'crosshair';
                        this.isPanning = false;
                    }
                });

                // Mouse events for panning
                this.canvas.addEventListener('mousedown', (e) => {
                    if (this.keys['Space']) {
                        this.isPanning = true;
                        this.lastPanX = e.clientX;
                        this.lastPanY = e.clientY;
                        this.canvas.style.cursor = 'grabbing';
                        e.preventDefault();
                    }
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.isPanning && this.keys['Space']) {
                        const dx = e.clientX - this.lastPanX;
                        const dy = e.clientY - this.lastPanY;
                        this.offsetX += dx;
                        this.offsetY += dy;
                        this.lastPanX = e.clientX;
                        this.lastPanY = e.clientY;
                        this.redraw();
                    }
                });

                // Color and stroke controls in main toolbar
                document.getElementById('strokeColor').addEventListener('change', (e) => {
                    if (this.selectedElement) {
                        this.selectedElement.strokeColor = e.target.value;
                        // If we are currently editing a text element, update the textarea color in real-time.
                        if (this.selectedElement.type === 'text' && this.textInput.style.display === 'block') {
                            this.textInput.style.color = e.target.value;
                        }
                        this.redraw();
                        this.saveState();
                    }
                });

                document.getElementById('fillColor').addEventListener('change', (e) => {
                    if (this.selectedElement) {
                        this.selectedElement.fillColor = e.target.value;
                        this.redraw();
                        this.saveState();
                    }
                });

                document.getElementById('strokeWidth').addEventListener('input', (e) => {
                    if (this.selectedElement) {
                        const newStrokeWidth = parseInt(e.target.value);
                        // For all elements, including text, this slider now controls strokeWidth
                        this.selectedElement.strokeWidth = newStrokeWidth;
                        this.redraw();
                        this.saveState();
                    }
                });

                // Action buttons
                document.getElementById('undoBtn').addEventListener('click', () => this.undo());
                document.getElementById('redoBtn').addEventListener('click', () => this.redo());
                document.getElementById('clearBtn').addEventListener('click', () => this.clear());
                document.getElementById('exportBtn').addEventListener('click', () => {
                    document.getElementById('exportModal').style.display = 'flex';
                });

                // Theme toggle button
                document.getElementById('themeToggleBtn').addEventListener('click', () => this.toggleTheme());

                document.getElementById('closeExportModal').addEventListener('click', () => {
                    document.getElementById('exportModal').style.display = 'none';
                });

                document.querySelectorAll('.export-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const format = e.target.dataset.format;
                        this.exportDrawing(format);
                        document.getElementById('exportModal').style.display = 'none';
                    });
                });

                // Info Modal Listeners
                document.getElementById('infoBtn').addEventListener('click', () => {
                    document.getElementById('infoModal').style.display = 'flex';
                });

                document.getElementById('closeInfoModal').addEventListener('click', () => {
                    document.getElementById('infoModal').style.display = 'none';
                });

                document.getElementById('importBtn').addEventListener('change', (e) => this.importDrawing(e));
                document.getElementById('imageInput').addEventListener('change', (e) => this.addImage(e));

                this.textInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.finishTextInput();
                    }
                });

                this.textInput.addEventListener('blur', () => {
                    this.finishTextInput();
                });

                // Close modal when clicking outside
                document.getElementById('exportModal').addEventListener('click', (e) => {
                    if (e.target.id === 'exportModal') {
                        document.getElementById('exportModal').style.display = 'none';
                    }
                });

                document.getElementById('infoModal').addEventListener('click', (e) => {
                    if (e.target.id === 'infoModal') {
                        document.getElementById('infoModal').style.display = 'none';
                    }
                });
            }

            updateToolbarsOnSelection() {
                const strokeColorInput = document.getElementById('strokeColor');
                const fillColorInput = document.getElementById('fillColor');
                const strokeWidthInput = document.getElementById('strokeWidth');

                if (this.selectedElement) {
                    const isPen = this.selectedElement.type === 'pen';

                    strokeColorInput.value = this.selectedElement.strokeColor || '#000000';

                    fillColorInput.disabled = isPen;
                    if (!fillColorInput.disabled) {
                        fillColorInput.value = this.selectedElement.fillColor || '#ffffff';
                    }

                    strokeWidthInput.disabled = false;
                    if (!strokeWidthInput.disabled) {
                        strokeWidthInput.value = this.selectedElement.strokeWidth || 1;
                    }

                } else {
                    // When nothing is selected, ensure the toolbars are enabled for the next drawing.
                    fillColorInput.disabled = false;
                    strokeWidthInput.disabled = false;
                }
            }

            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left - this.offsetX) / this.zoomLevel;
                const y = (e.clientY - rect.top - this.offsetY) / this.zoomLevel;
                return { x, y };
            }

            handleMouseDown(e) {
                if (this.isPanning) return;

                const pos = this.getMousePos(e);
                this.startX = pos.x;
                this.startY = pos.y;
                this.isDrawing = true;

                if (this.currentTool === 'select') {
                    const handleType = this.getHandleAt(pos.x, pos.y, this.selectedElement);
                    if (this.selectedElement && handleType) {
                        this.isResizing = true;
                        this.resizeHandle = handleType;
                        if (this.selectedElement.type === 'text') {
                            this.selectedElement.initialFontSize = this.selectedElement.fontSize;
                        }
                        this.initialBounds = {
                            x: this.selectedElement.x,
                            y: this.selectedElement.y,
                            width: this.selectedElement.width,
                            height: this.selectedElement.height
                        };
                    } else {
                        const clickedElement = this.getElementAt(pos.x, pos.y);
                        this.selectedElement = clickedElement; // Select the clicked element
                        
                        if (this.selectedElement) {
                            this.dragOffset.x = pos.x - this.selectedElement.x;
                            this.dragOffset.y = pos.y - this.selectedElement.y;
                            this.selectedElement._initialX = this.selectedElement.x; // Store initial position for dragging
                            this.selectedElement._initialY = this.selectedElement.y;
                            if (this.selectedElement.type === 'pen' && this.selectedElement.path) {
                                this.selectedElement._initialPath = JSON.parse(JSON.stringify(this.selectedElement.path));
                            }
                        }
                        this.updateToolbarsOnSelection();
                    }
                    this.redraw();
                } else if (this.currentTool === 'pen') {
                    this.penPath = [{ x: pos.x, y: pos.y }];
                    this.currentElement = this.createElement('pen', pos.x, pos.y, pos.x, pos.y);
                } else {
                    this.currentElement = this.createElement(this.currentTool, pos.x, pos.y, pos.x, pos.y);
                }
            }

            handleMouseMove(e) {
                if (!this.isDrawing || this.isPanning) return;

                const pos = this.getMousePos(e);

                if (this.currentTool === 'select' && this.selectedElement) {
                    if (this.isResizing) {
                        if (this.selectedElement.type === 'text') {
                            const dx = pos.x - this.startX;
                            const dy = pos.y - this.startY;
                            const initialFontSize = this.selectedElement.initialFontSize || this.selectedElement.fontSize;

                            // Use the larger of the horizontal or vertical drag to determine new size
                            const sizeChange = Math.abs(dx) > Math.abs(dy) ? dx : dy;
                            let newFontSize = initialFontSize + (sizeChange / 2); // Adjust sensitivity
                            
                            if (newFontSize < 4) newFontSize = 4; // Set a minimum font size
                            if (newFontSize > 512) newFontSize = 512; // Set a maximum font size

                            this.selectedElement.fontSize = newFontSize;

                        } else {
                            const dx = pos.x - this.startX;
                            const dy = pos.y - this.startY;

                            let newX = this.initialBounds.x;
                            let newY = this.initialBounds.y;
                            let newWidth = this.initialBounds.width;
                            let newHeight = this.initialBounds.height;

                            switch (this.resizeHandle) {
                                case 'tl':
                                    newX = this.initialBounds.x + dx;
                                    newY = this.initialBounds.y + dy;
                                    newWidth = this.initialBounds.width - dx;
                                    newHeight = this.initialBounds.height - dy;
                                    break;
                                case 'tm':
                                    newY = this.initialBounds.y + dy;
                                    newHeight = this.initialBounds.height - dy;
                                    break;
                                case 'tr':
                                    newY = this.initialBounds.y + dy;
                                    newWidth = this.initialBounds.width + dx;
                                    newHeight = this.initialBounds.height - dy;
                                    break;
                                case 'ml':
                                    newX = this.initialBounds.x + dx;
                                    newWidth = this.initialBounds.width - dx;
                                    break;
                                case 'mr':
                                    newWidth = this.initialBounds.width + dx;
                                    break;
                                case 'bl':
                                    newX = this.initialBounds.x + dx;
                                    newWidth = this.initialBounds.width - dx;
                                    newHeight = this.initialBounds.height + dy;
                                    break;
                                case 'bm':
                                    newHeight = this.initialBounds.height + dy;
                                    break;
                                case 'br':
                                    newWidth = this.initialBounds.width + dx;
                                    newHeight = this.initialBounds.height + dy;
                                    break;
                            }

                            if (newWidth < 10) newWidth = 10;
                            if (newHeight < 10) newHeight = 10;

                            this.selectedElement.x = newX;
                            this.selectedElement.y = newY;
                            this.selectedElement.width = newWidth;
                            this.selectedElement.height = newHeight;
                        }

                        this.redraw();
                    } else { // Dragging selected element
                        const dx = pos.x - (this.selectedElement._initialX + this.dragOffset.x);
                        const dy = pos.y - (this.selectedElement._initialY + this.dragOffset.y);
                        
                        this.selectedElement.x = this.selectedElement._initialX + dx;
                        this.selectedElement.y = this.selectedElement._initialY + dy;
                        if (this.selectedElement.type === 'pen' && this.selectedElement.path) {
                            this.selectedElement.path = this.selectedElement._initialPath.map(p => ({
                                x: p.x + dx,
                                y: p.y + dy
                            }));
                        }
                        this.redraw();
                    }
                } else if (this.currentTool === 'pen') {
                    if (!this.isDrawing) return;
                    this.penPath.push({ x: pos.x, y: pos.y });
                    this.currentElement.path = this.penPath;
                    this.redraw();
                } else if (this.currentTool === 'eraser') {
                    let elementsToKeep = [];
                    let elementsErasedThisMove = false;
                    for (let i = this.elements.length - 1; i >= 0; i--) {
                        const element = this.elements[i];
                        if (!this.isPointInElement(pos.x, pos.y, element, true)) {
                            elementsToKeep.unshift(element);
                        } else {
                            elementsErasedThisMove = true;
                        }
                    }
                    if (elementsErasedThisMove) {
                        this.elements = elementsToKeep;
                        this.redraw();
                    }
                } else if (this.currentElement) {
                    this.currentElement.width = pos.x - this.startX;
                    this.currentElement.height = pos.y - this.startY;
                    this.redraw();
                }
            }

            handleMouseUp(e) {
                if (!this.isDrawing) return;
                this.isDrawing = false;

                if (this.currentTool === 'eraser') {
                    this.saveState();
                } else if (this.currentTool === 'select' && this.selectedElement) {
                    const moved = this.selectedElement.x !== this.selectedElement._initialX || this.selectedElement.y !== this.selectedElement._initialY;
                    
                    if (this.isResizing || moved) {
                        if (this.isResizing) {
                            this.normalizeElement(this.selectedElement);
                        }
                        this.saveState();
                    }

                    this.isResizing = false;
                    delete this.selectedElement._initialX;
                    delete this.selectedElement._initialY;
                    if (this.selectedElement._initialPath) {
                        delete this.selectedElement._initialPath;
                    }
                }
                
                if (this.currentElement) {
                    if (this.currentTool === 'pen') {
                        if (this.penPath.length > 1) {
                            this.elements.push(this.currentElement);
                            this.saveState();
                        }
                    } else if (this.currentTool !== 'select') {
                        this.normalizeElement(this.currentElement);
                        this.elements.push(this.currentElement);
                        this.saveState();
                    }
                }

                this.currentElement = null;
                this.penPath = [];
                this.isDrawing = false;
            }

            handleDoubleClick(e) {
                
            }

            handleWheel(e) {
                e.preventDefault();
                const zoomIntensity = 0.1;
                const mouseX = e.clientX - this.canvas.getBoundingClientRect().left;
                const mouseY = e.clientY - this.canvas.getBoundingClientRect().top;
                
                const oldZoom = this.zoomLevel;
                let newZoom;

                if (e.deltaY < 0) {
                    newZoom = oldZoom * (1 + zoomIntensity);
                } else {
                    newZoom = oldZoom / (1 + zoomIntensity);
                }
                newZoom = Math.max(0.1, Math.min(5, newZoom)); // Limit zoom level

                const worldX = (mouseX - this.offsetX) / oldZoom;
                const worldY = (mouseY - this.offsetY) / oldZoom;

                this.offsetX = mouseX - worldX * newZoom;
                this.offsetY = mouseY - worldY * newZoom;
                
                this.zoomLevel = newZoom;

                this.redraw();
            }

            createElement(type, x, y, endX, endY, textContent = '') {
                const strokeColor = document.getElementById('strokeColor').value;
                const fillColor = document.getElementById('fillColor').value;
                const strokeWidth = parseInt(document.getElementById('strokeWidth').value);
                const element = {
                    type,
                    x,
                    y,
                    width: endX - x,
                    height: endY - y,
                    strokeColor,
                    fillColor,
                    strokeWidth,
                    id: Date.now() + Math.random()
                };

                if (type === 'pen') {
                    element.path = [];
                } else if (type === 'arrow') {
                    element.arrowheadSize = 10; // Default arrowhead size
                } else if (type === 'image') {
                    element.src = '';
                    element.image = new Image(); // Will be loaded later
                } 
                return element;
            }

            getElementAt(x, y) {
                for (let i = this.elements.length - 1; i >= 0; i--) {
                    const element = this.elements[i];
                    if (this.isPointInElement(x, y, element)) {
                        return element;
                    }
                }
                return null;
            }

            isPointInElement(x, y, element, isErasing = false) {
                const { x: ex, y: ey, width, height } = element;
                const tolerance = isErasing ? this.eraserRadius : this.selectionTolerance;

                if (element.type === 'rectangle' || element.type === 'image') {
                    const minX = Math.min(ex, ex + width) - tolerance;
                    const maxX = Math.max(ex, ex + width) + tolerance;
                    const minY = Math.min(ey, ey + height) - tolerance;
                    const maxY = Math.max(ey, ey + height) + tolerance;
                    return x >= minX && x <= maxX && y >= minY && y <= maxY;
                } else if (element.type === 'circle') {
                    const centerX = ex + width / 2;
                    const centerY = ey + height / 2;
                    const radiusX = Math.abs(width) / 2;
                    const radiusY = Math.abs(height) / 2;
                    // Check if point is inside ellipse with tolerance
                    const dx = (x - centerX) / (radiusX + tolerance);
                    const dy = (y - centerY) / (radiusY + tolerance);
                    return dx * dx + dy * dy <= 1;
                } else if (element.type === 'pen') {
                    if (!element.path || element.path.length === 0) return false;
                    for (let i = 0; i < element.path.length - 1; i++) {
                        const p1 = element.path[i];
                        const p2 = element.path[i + 1];
                        const dist = this.getDistanceToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                        if (dist <= (element.strokeWidth / 2) + tolerance) {
                            return true;
                        }
                    }
                    return false;
                } else if (element.type === 'line' || element.type === 'arrow') {
                    const x1 = ex;
                    const y1 = ey;
                    const x2 = ex + width;
                    const y2 = ey + height;
                    const dist = this.getDistanceToSegment(x, y, x1, y1, x2, y2);
                    return dist <= (element.strokeWidth / 2) + tolerance;
                } else if (element.type === 'triangle') {
                    const minX = Math.min(ex, ex + width) - tolerance;
                    const maxX = Math.max(ex, ex + width) + tolerance;
                    const minY = Math.min(ey, ey + height) - tolerance;
                    const maxY = Math.max(ey, ey + height) + tolerance;
                    return x >= minX && x <= maxX && y >= minY && y <= maxY;
                } else if (element.type === 'cylinder') {
                    const cylX = ex;
                    const cylY = ey;
                    const cylWidth = width;
                    const cylHeight = height;
                    const ellipseRadiusX = Math.abs(cylWidth) / 2;
                    const ellipseRadiusY = Math.abs(cylHeight) / 8;

                    const topEllipseCenterX = cylX + cylWidth / 2;
                    const topEllipseCenterY = cylY + ellipseRadiusY;
                    const dxTop = (x - topEllipseCenterX) / (ellipseRadiusX + tolerance);
                    const dyTop = (y - topEllipseCenterY) / (ellipseRadiusY + tolerance);
                    if (dxTop * dxTop + dyTop * dyTop <= 1) return true;

                    const bottomEllipseCenterX = cylX + cylWidth / 2;
                    const bottomEllipseCenterY = cylY + cylHeight - ellipseRadiusY;
                    const dxBottom = (x - bottomEllipseCenterX) / (ellipseRadiusX + tolerance);
                    const dyBottom = (y - bottomEllipseCenterY) / (ellipseRadiusY + tolerance);
                    if (dxBottom * dxBottom + dyBottom * dyBottom <= 1) return true;

                    const minX = Math.min(cylX, cylX + cylWidth) - tolerance;
                    const maxX = Math.max(cylX, cylX + cylWidth) + tolerance;
                    const minY = Math.min(cylY + ellipseRadiusY, cylY + cylHeight - ellipseRadiusY) - tolerance;
                    const maxY = Math.max(cylY + ellipseRadiusY, cylY + cylHeight - ellipseRadiusY) + tolerance;
                    return x >= minX && x <= maxX && y >= minY && y <= maxY;
                } else if (element.type === 'cloud') {
                    const minX = Math.min(ex, ex + width) - tolerance;
                    const maxX = Math.max(ex, ex + width) + tolerance;
                    const minY = Math.min(ey, ey + height) - tolerance;
                    const maxY = Math.max(ey, ey + height) + tolerance;
                    return x >= minX && x <= maxX && y >= minY && y <= maxY;
                }
                return false;
            }

            getDistanceToSegment(px, py, x1, y1, x2, y2) {
                const l2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
                if (l2 === 0) return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
                let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
                t = Math.max(0, Math.min(1, t));
                const nearestX = x1 + t * (x2 - x1);
                const nearestY = y1 + t * (y2 - y1);
                return Math.sqrt((px - nearestX) * (px - nearestX) + (py - nearestY) * (py - nearestY));
            }

            getHandleAt(x, y, element) {
                if (!element || element.type === 'pen') return null;
                const { x: elX, y: elY, width: elW, height: elH } = element;
                const handles = {
                    tl: { x: elX, y: elY },
                    tm: { x: elX + elW / 2, y: elY },
                    tr: { x: elX + elW, y: elY },
                    ml: { x: elX, y: elY + elH / 2 },
                    mr: { x: elX + elW, y: elY + elH / 2 },
                    bl: { x: elX, y: elY + elH },
                    bm: { x: elX + elW / 2, y: elY + elH },
                    br: { x: elX + elW, y: elY + elH }
                };
                const handleSize = 8 / this.zoomLevel;
                for (const key in handles) {
                    const handle = handles[key];
                    if (x >= handle.x - handleSize / 2 && x <= handle.x + handleSize / 2 &&
                        y >= handle.y - handleSize / 2 && y <= handle.y + handleSize / 2) {
                        return key;
                    }
                }
                return null;
            }

            redraw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.save();
                this.ctx.translate(this.offsetX, this.offsetY);
                this.ctx.scale(this.zoomLevel, this.zoomLevel);

                this.elements.forEach(element => {
                    this.drawElement(element);
                });

                if (this.currentElement && this.currentTool !== 'select' && this.currentTool !== 'text') {
                    this.drawElement(this.currentElement);
                }

                if (this.selectedElement) {
                    this.drawSelectionOutline(this.selectedElement);
                }

                this.ctx.restore();
            }

            drawElement(element) {
                this._drawElementInternal(element, this.ctx, this.rc);
            }

            _drawElementInternal(element, ctx, rc) {
                const { type, x, y, width, height, strokeColor, fillColor, strokeWidth } = element;

                const roughOptions = {
                    stroke: strokeColor,
                    fill: (element.type === 'text' || fillColor === 'transparent') ? 'none' : fillColor,
                    strokeWidth: strokeWidth,
                    roughness: this.roughness,
                    fillStyle: (fillColor === '#ffffff' || fillColor === 'transparent' || element.type === 'text') ? 'hachure' : 'solid'
                };

                switch (type) {
                    case 'rectangle':
                        rc.rectangle(x, y, width, height, roughOptions);
                        break;
                    case 'circle':
                        rc.ellipse(x + width / 2, y + height / 2, width, height, roughOptions);
                        break;
                    case 'line':
                        rc.line(x, y, x + width, y + height, roughOptions);
                        break;
                    case 'triangle':
                        rc.polygon([
                            [x + width / 2, y],
                            [x, y + height],
                            [x + width, y + height]
                        ], roughOptions);
                        break;
                    case 'cylinder':
                        const ellipseRadiusX = Math.abs(width) / 2;
                        const ellipseRadiusY = Math.abs(height) / 8;
                        const topEllipseCenterY = y + ellipseRadiusY;
                        const bottomEllipseCenterY = y + height - ellipseRadiusY;

                        // Draw the two vertical side lines
                        rc.line(x, topEllipseCenterY, x, bottomEllipseCenterY, roughOptions);
                        rc.line(x + width, topEllipseCenterY, x + width, bottomEllipseCenterY, roughOptions);

                        // Draw the bottom arc (convex)
                        const bottomArcPath = `M ${x} ${bottomEllipseCenterY} A ${ellipseRadiusX} ${ellipseRadiusY} 0 0 1 ${x + width} ${bottomEllipseCenterY}`;
                        rc.path(bottomArcPath, { ...roughOptions, fill: 'none' });

                        // Draw the top ellipse (filled, will cover the back of the lines)
                        rc.ellipse(x + width / 2, topEllipseCenterY, width, ellipseRadiusY * 2, roughOptions);
                        break;
                    case 'cloud':
                        const cloudPath = `M ${x + width * 0.2} ${y + height * 0.7} C ${x - width * 0.1} ${y + height * 0.9}, ${x + width * 0.1} ${y + height * 0.3}, ${x + width * 0.4} ${y + height * 0.2} C ${x + width * 0.8} ${y - height * 0.1}, ${x + width * 1.1} ${y + height * 0.2}, ${x + width * 0.9} ${y + height * 0.5} C ${x + width * 1.2} ${y + height * 0.8}, ${x + width * 0.8} ${y + height * 1.1}, ${x + width * 0.5} ${y + height * 0.9} C ${x + width * 0.2} ${y + height * 1.1}, ${x + width * 0.0} ${y + height * 0.9}, ${x + width * 0.2} ${y + height * 0.7} Z`;
                        rc.path(cloudPath, roughOptions);
                        break;
                    case 'arrow':
                        rc.line(x, y, x + width, y + height, roughOptions);
                        const angle = Math.atan2(height, width);
                        const size = element.arrowheadSize || 10;
                        const x2 = x + width;
                        const y2 = y + height;
                        const p1 = [ x2 - size * Math.cos(angle - Math.PI / 6), y2 - size * Math.sin(angle - Math.PI / 6) ];
                        const p2 = [x2, y2];
                        const p3 = [ x2 - size * Math.cos(angle + Math.PI / 6), y2 - size * Math.sin(angle + Math.PI / 6) ];
                        rc.polygon([p1, p2, p3], roughOptions);
                        break;
                    case 'pen':
                        if (element.path && element.path.length > 1) {
                            const points = element.path.map(p => [p.x, p.y]);
                            const drawable = rough.generator().linearPath(points, roughOptions);
                            rc.draw(drawable);
                        }
                        break;
                    
                    case 'image':
                        if (element.image && element.image.complete && element.image.naturalWidth !== 0) {
                            ctx.drawImage(element.image, x, y, width, height);
                        } else if (element.src) {
                            element.image = new Image();
                            element.image.onload = () => {
                                this.redraw();
                            };
                            element.image.src = element.src;
                        }
                        break;
                }
            }

            drawSelectionOutline(element) {
                const ctx = this.ctx;
                const { x, y, width, height, type } = element;

                ctx.save();
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2 / this.zoomLevel;
                ctx.setLineDash([5, 5]);

                let outlineX = x;
                let outlineY = y;
                let outlineWidth = width;
                let outlineHeight = height;

                ctx.strokeRect(outlineX, outlineY, outlineWidth, outlineHeight);
                ctx.setLineDash([]);

                if (type !== 'pen') {
                    const handleSize = 8 / this.zoomLevel;
                    ctx.fillStyle = '#3b82f6';
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1 / this.zoomLevel;

                    const handles = [
                        { x: outlineX, y: outlineY },
                        { x: outlineX + outlineWidth / 2, y: outlineY },
                        { x: outlineX + outlineWidth, y: outlineY },
                        { x: outlineX, y: outlineY + outlineHeight / 2 },
                        { x: outlineX + outlineWidth, y: outlineY + outlineHeight / 2 },
                        { x: outlineX, y: outlineY + outlineHeight },
                        { x: outlineX + outlineWidth / 2, y: outlineY + outlineHeight },
                        { x: outlineX + outlineWidth, y: outlineY + outlineHeight }
                    ];

                    handles.forEach(handle => {
                        ctx.beginPath();
                        ctx.rect(handle.x - handleSize / 2, handle.y - handleSize / 2, handleSize, handleSize);
                        ctx.fill();
                        ctx.stroke();
                    });
                }
                ctx.restore();
            }

            normalizeElement(element) {
                if (!element || element.type === 'pen' || element.type === 'line' || element.type === 'arrow') {
                    return;
                }
                if (element.width < 0) {
                    element.x += element.width;
                    element.width = Math.abs(element.width);
                }
                if (element.height < 0) {
                    element.y += element.height;
                    element.height = Math.abs(element.height);
                }
            }

            // History Management
            saveState() {
                this.history = this.history.slice(0, this.historyIndex + 1);
                this.history.push(JSON.parse(JSON.stringify(this.elements)));
                this.historyIndex++;
            }

            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.elements = JSON.parse(JSON.stringify(this.history[this.historyIndex]));
                    this.selectedElement = null; // Deselect on undo
                    this.updateToolbarsOnSelection();
                    this.redraw();
                }
            }

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.elements = JSON.parse(JSON.stringify(this.history[this.historyIndex]));
                    this.selectedElement = null; // Deselect on redo
                    this.updateToolbarsOnSelection();
                    this.redraw();
                }
            }

            clear() {
                if (confirm('Are you sure you want to clear the canvas?')) {
                    this.elements = [];
                    this.history = [];
                    this.historyIndex = -1;
                    this.selectedElement = null;
                    this.clipboard = null;
                    this.redraw();
                    this.saveState();
                    this.updateToolbarsOnSelection();
                }
            }

            deleteSelectedElement() {
                if (this.selectedElement) {
                    this.elements = this.elements.filter(el => el.id !== this.selectedElement.id);
                    this.selectedElement = null;
                    this.updateToolbarsOnSelection();
                    this.redraw();
                    this.saveState();
                }
            }

            

            // Clipboard functions (simplified for single element)
            copySelectedElement() {
                if (this.selectedElement) {
                    this.clipboard = JSON.parse(JSON.stringify(this.selectedElement));
                }
            }

            pasteElement() {
                if (this.clipboard) {
                    const pasteOffset = 20;
                    const newElement = JSON.parse(JSON.stringify(this.clipboard));
                    newElement.id = Date.now() + Math.random();
                    newElement.x += pasteOffset;
                    newElement.y += pasteOffset;
                    if (newElement.type === 'pen' && newElement.path) {
                        newElement.path = newElement.path.map(p => ({ x: p.x + pasteOffset, y: p.y + pasteOffset }));
                    }
                    if (newElement.type === 'image' && newElement.src) {
                        newElement.image = new Image();
                        newElement.image.onload = () => {
                            this.redraw();
                        };
                        newElement.image.src = newElement.src;
                    }
                    this.elements.push(newElement);
                    this.selectedElement = newElement;
                    this.updateToolbarsOnSelection();
                    this.redraw();
                    this.saveState();
                }
            }

            // Export and Import
            exportDrawing(format) {
                if (format === 'json') {
                    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.elements, null, 2));
                    const downloadAnchorNode = document.createElement('a');
                    downloadAnchorNode.setAttribute("href", dataStr);
                    downloadAnchorNode.setAttribute("download", "drawing.json");
                    document.body.appendChild(downloadAnchorNode);
                    downloadAnchorNode.click();
                    downloadAnchorNode.remove();
                    return;
                }

                if (format === 'svg') {
                    // Create a <g> element to act as a container for all shapes.
                    const svgContainer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    // Initialize roughSvg WITHOUT a host element. It will return nodes instead of appending them.
                    const roughSvg = rough.svg();

                    this.elements.forEach(element => {
                        const { type, x, y, width, height, strokeColor, fillColor, strokeWidth } = element;
                        const o = {
                            stroke: strokeColor,
                            fill: (fillColor === 'transparent' || element.type === 'text' || element.type === 'pen') ? 'none' : fillColor,
                            strokeWidth: strokeWidth,
                            roughness: this.roughness,
                            fillStyle: (fillColor === '#ffffff' || fillColor === 'transparent' || element.type === 'text') ? 'hachure' : 'solid'
                        };

                        let el = null; // Holds the generated element

                        switch(element.type) {
                            case 'rectangle':
                                el = roughSvg.rectangle(x, y, width, height, o);
                                break;
                            case 'circle':
                                el = roughSvg.ellipse(x + width / 2, y + height / 2, width, height, o);
                                break;
                            case 'line':
                                el = roughSvg.line(x, y, x + width, y + height, o);
                                break;
                            case 'triangle':
                                 el = roughSvg.polygon([
                                    [x + width / 2, y],
                                    [x, y + height],
                                    [x + width, y + height]
                                ], o);
                                break;
                            case 'pen':
                                if (element.path && element.path.length > 1) {
                                    const points = element.path.map(p => [p.x, p.y]);
                                    const drawable = rough.generator().linearPath(points, o);
                                    el = roughSvg.draw(drawable);
                                }
                                break;
                            case 'arrow':
                                const arrowLine = roughSvg.line(x, y, x + width, y + height, o);
                                const angle = Math.atan2(height, width);
                                const size = element.arrowheadSize || 10;
                                const x2 = x + width;
                                const y2 = y + height;
                                const p1 = [ x2 - size * Math.cos(angle - Math.PI / 6), y2 - size * Math.sin(angle - Math.PI / 6) ];
                                const p2 = [x2, y2];
                                const p3 = [ x2 - size * Math.cos(angle + Math.PI / 6), y2 - size * Math.sin(angle + Math.PI / 6) ];
                                const arrowhead = roughSvg.polygon([p1, p2, p3], o);
                                svgContainer.appendChild(arrowLine);
                                svgContainer.appendChild(arrowhead);
                                break; // Composite shape, parts are already appended
                            case 'cylinder':
                                const ellipseRadiusX_svg = Math.abs(width) / 2;
                                const ellipseRadiusY_svg = Math.abs(height) / 8;
                                const topEllipseY_svg = y + ellipseRadiusY_svg;
                                const bottomEllipseY_svg = y + height - ellipseRadiusY_svg;

                                const topEllipse = roughSvg.ellipse(x + width / 2, topEllipseY_svg, width, ellipseRadiusY_svg * 2, o);
                                const bottomArcPath = `M ${x},${bottomEllipseY_svg} A ${ellipseRadiusX_svg},${ellipseRadiusY_svg} 0 0 1 ${x + width},${bottomEllipseY_svg}`;
                                const bottomHalfEllipse = roughSvg.path(bottomArcPath, {...o, fill: 'none'});
                                const leftLine = roughSvg.line(x, topEllipseY_svg, x, bottomEllipseY_svg, o);
                                const rightLine = roughSvg.line(x + width, topEllipseY_svg, x + width, bottomEllipseY_svg, o);
                                
                                svgContainer.appendChild(leftLine);
                                svgContainer.appendChild(rightLine);
                                svgContainer.appendChild(bottomHalfEllipse);
                                svgContainer.appendChild(topEllipse);
                                break; // Composite shape, parts are already appended
                            case 'cloud':
                                const cloudPath = `M ${x + width * 0.2} ${y + height * 0.7} C ${x - width * 0.1} ${y + height * 0.9}, ${x + width * 0.1} ${y + height * 0.3}, ${x + width * 0.4} ${y + height * 0.2} C ${x + width * 0.8} ${y - height * 0.1}, ${x + width * 1.1} ${y + height * 0.2}, ${x + width * 0.9} ${y + height * 0.5} C ${x + width * 1.2} ${y + height * 0.8}, ${x + width * 0.8} ${y + height * 1.1}, ${x + width * 0.5} ${y + height * 0.9} C ${x + width * 0.2} ${y + height * 1.1}, ${x + width * 0.0} ${y + height * 0.9}, ${x + width * 0.2} ${y + height * 0.7} Z`;
                                el = roughSvg.path(cloudPath, o);
                                break;
                            
                            case 'image':
                                if (element.src) {
                                    const imageEl = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                                    imageEl.setAttribute('href', element.src);
                                    imageEl.setAttribute('x', x);
                                    imageEl.setAttribute('y', y);
                                    imageEl.setAttribute('width', width);
                                    imageEl.setAttribute('height', height);
                                    el = imageEl;
                                }
                                break;
                        }
                        // For simple shapes, append the generated element now.
                        if (el) {
                            svgContainer.appendChild(el);
                        }
                    });

                    // Apply the pan and zoom transform to the container group.
                    svgContainer.setAttribute('transform', `translate(${this.offsetX} ${this.offsetY}) scale(${this.zoomLevel})`);

                    // Create the final SVG string, embedding the container's outerHTML.
                    const svgContent = `<svg width="${this.canvas.width}" height="${this.canvas.height}" viewBox="0 0 ${this.canvas.width} ${this.canvas.height}" xmlns="http://www.w3.org/2000/svg">${svgContainer.outerHTML}</svg>`;

                    const blob = new Blob([svgContent], { type: 'image/svg+xml' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'drawing.svg';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    return;
                }

                // For PNG, JPG, PDF
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = this.canvas.width;
                tempCanvas.height = this.canvas.height;
                const tempRc = rough.canvas(tempCanvas);

                tempCtx.translate(this.offsetX, this.offsetY);
                tempCtx.scale(this.zoomLevel, this.zoomLevel);

                this.elements.forEach(element => {
                    this._drawElementInternal(element, tempCtx, tempRc);
                });
                
                tempCtx.setTransform(1, 0, 0, 1, 0, 0);

                const imageData = tempCanvas.toDataURL(`image/${format === 'jpg' ? 'jpeg' : 'png'}`, 1.0);
                if (format === 'pdf') {
                    const { jsPDF } = window.jspdf;
                    const pdf = new jsPDF({ orientation: 'landscape', unit: 'px', format: [tempCanvas.width, tempCanvas.height] });
                    pdf.addImage(imageData, 'PNG', 0, 0, tempCanvas.width, tempCanvas.height);
                    pdf.save("drawing.pdf");
                } else {
                    const a = document.createElement('a');
                    a.href = imageData;
                    a.download = `drawing.${format}`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                }
            }

            importDrawing(event) {
                const file = event.target.files[0];
                if (!file) {
                    return;
                }
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedElements = JSON.parse(e.target.result);
                        importedElements.forEach(el => {
                            if (el.type === 'image' && el.src) {
                                el.image = new Image();
                                el.image.onload = () => {
                                    this.redraw();
                                };
                                el.image.src = el.src;
                            }
                        });
                        this.elements = importedElements;
                        this.saveState();
                        this.redraw();
                        alert('Drawing imported successfully!');
                    } catch (error) {
                        alert('Failed to import drawing: Invalid JSON file. Error: ' + error.message);
                        console.error('Import error:', error);
                    }
                };
                reader.readAsText(file);
            }

            addImage(event) {
                const file = event.target.files[0];
                if (!file) {
                    return;
                }
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const imgWidth = img.naturalWidth;
                        const imgHeight = img.naturalHeight;
                        const centerX = (this.canvas.width / 2 - this.offsetX) / this.zoomLevel;
                        const centerY = (this.canvas.height / 2 - this.offsetY) / this.zoomLevel;
                        
                        const defaultWidth = 100 / this.zoomLevel;
                        const defaultHeight = (imgHeight / imgWidth) * defaultWidth;

                        const newImageElement = this.createElement('image', centerX - defaultWidth / 2, centerY - defaultHeight / 2, defaultWidth, defaultHeight);
                        newImageElement.src = e.target.result;
                        newImageElement.image = img;
                        newImageElement.width = defaultWidth;
                        newImageElement.height = defaultHeight;

                        this.elements.push(newImageElement);
                        this.selectedElement = newImageElement;
                        this.redraw();
                        this.saveState();
                        this.updateToolbarsOnSelection();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            // Theme toggle
            loadTheme() {
                const savedTheme = localStorage.getItem('theme');
                if (savedTheme === 'dark') {
                    this.isDarkMode = true;
                    document.body.classList.add('dark-mode');
                } else {
                    this.isDarkMode = false;
                    document.body.classList.remove('dark-mode');
                }
                this.updateThemeIcon();
            }

            toggleTheme() {
                this.isDarkMode = !this.isDarkMode;
                if (this.isDarkMode) {
                    document.body.classList.add('dark-mode');
                    localStorage.setItem('theme', 'dark');
                } else {
                    document.body.classList.remove('dark-mode');
                    localStorage.setItem('theme', 'light');
                }
                this.updateThemeIcon();
            }

            updateThemeIcon() {
                if (this.isDarkMode) {
                    this.themeToggleBtn.innerHTML = this.moonIconSVG;
                } else {
                    this.themeToggleBtn.innerHTML = this.sunIconSVG;
                }
            }
        }

        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            window.drawingApp = new DrawingApp();
        });

        // Prevent context menu on canvas
        document.addEventListener('contextmenu', (e) => {
            if (e.target.tagName === 'CANVAS') {
                e.preventDefault();
            }
        });

        // Handle window unload
        window.addEventListener('beforeunload', (e) => {
            if (window.drawingApp && window.drawingApp.elements.length > 0) {
                e.preventDefault();
                e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
            }
        });
    </script>
</body>
</html>